[{"title":"Java GC 笔记","date":"2018-04-02T06:43:00.000Z","path":"2018/04/02/Java GC笔记/","text":"Java程序不用像C++程序在程序中自行处理内存的回收释放。这是因为Java在JVM虚拟机上增加了垃圾回收(GC)机制，用以在合适的时间触发垃圾回收，将不需要的内存空间回收释放，避免无限制的内存增长导致的OOM。 回收前的准备垃圾回收器在对堆进行回收前，第一件事情就是要确定这些对象哪些还“存活”，哪些已经“死去”。 引用计数算法给对象中添加一个引用计数器，每当有一个地方引用它，计数器加1，当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能在被使用的。它实现简单，判定效率高，但主流的Java虚拟机都不用它来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。 可达性反洗算法通过一系列称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。即使有的对象相互关联，只要GC Roots不可达，均被判定为可回收对象。这也是主流的实现方法。 Java中可作为GC Roots的对象： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 对象的自救在可达性算法中判断为不可达的对象时，它们不会立即被回收，真正宣告一个对象死亡，还需要判断该对象是否有必要执行finalize()方法，当对象没有覆盖该方法，或者已经执行过该方法，虚拟机会将这两种情况视为没有必要执行。如果对象有必要执行该方法，该对象会被放在名为F-Queue的队列中，虚拟机会建立一个低优先级的FInalizer线程去执行该方法，并不保证等它运行结束，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，很可能会导致F-Queue队列一直等待。如果在执行中重新与引用链上的任何一个对象建立关联，如把自己复制给某个类变量或者对象的成员变量，那么就可以逃脱这一次回收。 回收算法标记-清楚算法首先标记出所有需要回收的对象， 在标记完成后统一回收。如图： 不足：标记和清除两个过程效率都不高；标记清除后产生大量不连续的内存碎片，导致以后运行的时候要分配较大对象时，无法找到足够的连续内存而不得不再一次垃圾回收。 复制算法将内存按容量大小划分为大小相等的两块，每次使用其中一块，当这一块用完了，就将还存活着的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。 标记-整理算法同标记清理算法一样，首先标记对象，但后续步骤不是直接清理，而是将所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集Java堆主要分为新生代和老年代。对于新生代，每次收集都有大量对象死去，所以采用“复制算法”，将少量存货对象副职即可完成收集；对于老年代，其中的对象存活率高、没有额外空间对它们进行分配担保，必须使用“标记清除算法”或“标记整理算法”来收集。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.yuanyang-miemie.win/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://www.yuanyang-miemie.win/tags/JVM/"}]},{"title":"简单工厂模式","date":"2018-03-14T14:35:01.000Z","path":"2018/03/14/简单工厂模式/","text":"工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 工厂模式有三种：简单工厂模式、工厂方法模式、抽象工厂模式 这里先介绍简单工厂模式 简单工厂模式又称静态工厂方法模式，从名字来看，这种模式体现的就是简单。主要的实现思想是通过创建一个工厂类，通过调用工厂方法的静态方法返回相应的对象。例如有一个计算程序：输入两个数和运算符号（+-*/），输出运算结果。可以这样写： 12345678910111213141516171819202122Scanner scanner = new Scanner(System.in);System.out.println(&quot;请输入第一个数：&quot;);String number1 = scanner.next();System.out.println(&quot;请输入第二个数：&quot;);String number2 = scanner.next();System.out.println(&quot;请输入运算符号：&quot;);String operation = scanner.next();switch (operation)&#123; case &quot;+&quot;: System.out.println(Integer.valueOf(number1) + Integer.valueOf(number2)); break; case &quot;-&quot;: System.out.println(Integer.valueOf(number1) - Integer.valueOf(number2)); break; case &quot;*&quot;: System.out.println(Integer.valueOf(number1) * Integer.valueOf(number2)); break; case &quot;/&quot;: System.out.println(Integer.valueOf(number1) / Integer.valueOf(number2)); break;&#125;scanner.close(); 当然，这只是最简单的实现，并且没有对除数为0等做处理，这样做也行，但如果后面要添加更多的计算方法，比如开方、乘方等，那么就要无限的增加switch分支，让程序难以维护。所以可以采用简单工厂的方式实现：1234567891011121314151617181920212223public abstract class Operation &#123; private double number1 = 0; private double number2 = 0; public double getNumber1() &#123; return number1; &#125; public void setNumber1(double number1) &#123; this.number1 = number1; &#125; public double getNumber2() &#123; return number2; &#125; public void setNumber2(double number2) &#123; this.number2 = number2; &#125; public abstract double getResult();&#125; 运算抽象类，后面的运算规则通过继承这个类进行运算。123456789101112131415161718192021222324public class AddOperation extends Operation &#123; @Override public double getResult() &#123; return getNumber1() + getNumber2(); &#125;&#125;public class SubOperation extends Operation &#123; @Override public double getResult() &#123; return getNumber1() - getNumber2(); &#125;&#125;public class MulOperation extends Operation &#123; @Override public double getResult() &#123; return getNumber1() * getNumber2(); &#125;&#125;public class DivOperation extends Operation &#123; @Override public double getResult() &#123; return getNumber1() / getNumber2(); &#125;&#125; 定义一个构造计算方法的工厂：12345678910111213141516171819202122public class OperationFactory &#123; public static Operation createOperation(char operate)&#123; Operation operation = null; switch (operate)&#123; case &apos;+&apos;: operation = new AddOperation(); break; case &apos;-&apos;: operation = new SubOperation(); break; case &apos;*&apos;: operation = new MulOperation(); break; case &apos;/&apos;: operation = new DivOperation(); break; &#125; return operation; &#125;&#125; 这样就能通过这个简单工厂来创建相应的运算对象（当然，有很多细节没有进行处理）。12345678910111213141516Scanner scanner = new Scanner(System.in);System.out.println(&quot;请输入第一个数：&quot;);String number1 = scanner.next();System.out.println(&quot;请输入第二个数：&quot;);String number2 = scanner.next();System.out.println(&quot;请输入运算符号：&quot;);String operation = scanner.next();Operation o = null;try &#123; o = OperationFactory.createOperation(operation.charAt(0)); o.setNumber1(Double.valueOf(number1)); o.setNumber2(Double.valueOf(number2));&#125;catch (Exception e)&#123;&#125;System.out.println(o.getResult());","tags":[{"name":"java","slug":"java","permalink":"http://www.yuanyang-miemie.win/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.yuanyang-miemie.win/tags/设计模式/"}]},{"title":"Executor 框架详解","date":"2018-03-14T08:35:01.000Z","path":"2018/03/14/Executor 框架详解/","text":"Executor框架最核心的类是ThreadPoolExecutor,它是Java线程池的实现类，通过Executors工具类，可以创建3种类型的ThreadPoolExecutor:首先附上ThreadPoolExecutor的构造函数1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) FixedThreadPool可重用==固定线程数==的线程池。实现源码： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 在这里，corePoolSize和maximumPoolSize都设置成了创建时指定的线程数nThread，当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的时间，超过这个时间后线程将会被终止。在这里设置为0L，意味着多余的空闲线程将会被立即终止。 FixedPoolThread的execute()方法运行流程如下： 如果当前运行的线程少于corePoolSize，则创建新的线程来执行任务。 在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue 线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行 由于它采用了LinkedBlockingQueue来作为线程池的工作队列，这是一个无界队列（队列容量为Integer.MAX_VALUE）。所以将会为线程池带来如下影响： 当线程池的线程数达到corePoolSize之后，新的任务将会在无界队列中等待，因此线程池中的线程不会超过corePoolSize 由于1，使用无界队列时maximumPoolSize将是一个无效参数； 由于1和2，使用无界队列时keepAliveTime将是一个无效参数 由于使用无界队列，运行中的FixedThreadPool(未执行shutdown()或shutdownNow())不会拒绝任务。 SingleThreadExecutor使用单个worker线程的Executor，下面是源码实现：123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; SingleThreadExecutor的corePoolSize和maximumPoolSize都被设置成1,其他参数则与FixedThreadPool相同,它使用无界队列的影响与FixedThreadPool是同样的。下面是它的运行流程图： 如果当前没有线程在运行，则创建一个新的线程 当线程池中有且仅有一个运行的线程，将任务加入LinkedBlockingQueue 线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务执行。 CachedThreadPool一个会根据需要创建新线程的线程池，下面是源码实现：12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 它的corePoolSize被设置为0，maximumPoolSize设置为Integer.MAX_VALUE,即maximumPool是无界的；把keepAliveTime设置成60L，意味着该线程池中空闲线程等待新任务的最长时间为60秒，超时则被会终止。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的,意味着，如果主线程提交任务的速度高于maximumPool中线程处理的速度，它将会不断的创建新的线程，直到耗尽所有CPU和内存资源。它的运行流程如图： 首先执行SynchronousQueue.offer(task)，如果当前maximumPool中有空闲线程正在执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS),那么主线程执行的offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute执行成功，否则执行下面的操作。 当maximumPool为空，或者其中没有空闲线程时，将没有线程执行poll操作，那么CachedThreadPool会创建一个新的线程，execute方法执行成功。 在上面的步骤中，线程将任务执行完后，变为空闲状态，将会执行poll操作，空闲线程继续等待新的任务到来并配对执行，如果超过60s，则线程将会被终止。由于超过60秒的空闲线程将会被终止，所以长时间保持空闲的CachedThreadPool不会使用任何资源。 CachedThreadPool的任务传递示意图： ScheduledThreadPoolExecutor主要用来在给定的延迟之后运行任务，或者定期执行任务，下面是源码实现：1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; 该类直接继承自ThreadPoolExecutor，为的是能直接使用已经实现的方法，而且，它新加了几个方法： public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)//向定时任务线程池提交一个延时Runnable任务（仅执行一次） public ScheduledFuture schedule(Callable callable, long delay, TimeUnit unit);//向定时任务线程池提交一个延时的Callable任务（仅执行一次） public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay,long period, TimeUnit unit)//向定时任务线程池提交一个固定时间间隔执行的任务 public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay,long delay, TimeUnit unit);//向定时任务线程池提交一个固定延时间隔执行的任务 也可以向其直接提交普通任务，相当于延时和周期都为0的任务。这里构造时的数值含义与前面的类似，就不赘述了。下面是基本运行流程图： 主线程提交普通任务或有延时或周期的任务。并将任务加入具有优先性质的阻塞队列。 线程池中的线程每次通过take()方法获取任务，然后从任务的getDelay()方法获取应当延时的时间，当延时达到，执行任务。执行完毕后，判断这是不是一个周期任务，如果是，则继续延时执行任务，如果不是，则继续调用take方法获取任务，如果没有获取到任务，空闲线程将会被终止。 FutureTask代表异步计算的结果，根据FutureTask.run()方法执行状况，可以分为下面三种状态： 未启动：FutureTask.run()方法还没有被执行前 已启动：FutureTask.run()方法正在执行 已完成：FutureTask.run()方法正常结束、被取消、执行抛出异常、异常结束 下面是FutureTask对应get(),cancel()方法执行示意图：","tags":[{"name":"java","slug":"java","permalink":"http://www.yuanyang-miemie.win/tags/java/"}]},{"title":"Executor 框架","date":"2018-03-14T02:35:01.000Z","path":"2018/03/14/executor 框架/","text":"Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。 Executor 框架简介在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也被收回。操作系统会调度所有线程并将他们分配给可用的CPU。如图 Executor 框架结构主要由3大部分组成： 任务：包括被执行任务需要实现的接口：Runnable接口和Callable接口 任务的执行：包括任务执行机制的核心接口Executor，以及继承自它的ExecutorService接口。有两个关键类实现了ExecutorService接口(ThreadPoolExecutor和ScheduledThreadPoolExecutor)。 异步计算的结果：包括接口Future和实现它的FutureTask类 Executor框架的成员 ThreadPoolExecutor：通常使用工具类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor: SingleThreadExecutor:用于需要保证顺序地执行每个任务，并且在任意时间点不会有多个线程是活动的应用场景。下面是创建单个线程的API 12public static ExecutorService newSingleThreadExecutor();public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) FixedThreadPool：用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。下面是创建使用固定线程数的FixedThreadPool的API 12public static ExecutorService newFixedThreadPool(int nThreads);public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory); CachedThreadPool:它是无界大小的线程池，用于执行很多短期异步小任务的小程序,或者是负载比较轻的服务器。下面是创建一个根据需要创建新线程的API 12public static ExecutorService newCachedThreadPool();public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory); ScheduledThreadPoolExecutor：通常使用工具类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor: ScheduledThreadPoolExecutor：包含若干个线程的ScheduledThreadPoolExecutor，适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的场景。下面是创建的API： 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize);public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory); SingleThreadScheduledExecutor：只包含一个线程的ScheduledThreadPoolExecutor，适用于需要单个线程执行周期任务，同时需要保证顺序地执行各个任务的场景。下面是创建的API： 12public static ScheduledExecutorService newSingleThreadScheduledExecutor();public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory); Future接口Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。下面是对应API： 123public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)public Future&lt;?&gt; submit(Runnable task) Runnable接口和Callable接口这两个接口的实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行，最后一个方法没有返回值，其他均可以通过得到的FutureTask对象的get方法获取执行后结果。 12345678910111213141516171819202122232425262728293031public class ExecutorTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executor = Executors.newFixedThreadPool(5); //submit(Runnable task) Future&lt;String&gt; f1 = executor.submit(new Runnable()&#123; @Override public void run() &#123; System.out.println(1); &#125; &#125;,&quot;result&quot;); System.out.println(f1.get()); //submit(Runnable task,T result) Future f2 = executor.submit(new Runnable()&#123; @Override public void run() &#123; System.out.println(2); &#125; &#125;); System.out.println(f2.get()); //submit(Callable&lt;T&gt; task) Future&lt;String&gt; f3 = executor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; System.out.println(3); return &quot;result&quot;; &#125; &#125;); System.out.println(f3.get()); &#125;&#125; 执行结果1234561result2null3result 除了自己实现Callable接口外，Executors可以把一个Runnable包装成一个Callable，下面是对应的API12public static Callable&lt;Object&gt; callable(Runnable task)public static Callable&lt;T&gt; callable(Runnable task, T result) 此时将这种转换过的对象交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，第一个种转换方法不会有返回值。123456789101112131415161718Callable c1 = Executors.callable(new Runnable() &#123; @Override public void run() &#123; System.out.println(4); &#125;&#125;);Callable c2 = Executors.callable(new Runnable() &#123; @Override public void run() &#123; System.out.println(5); &#125;&#125;,&quot;result2&quot;);Future f4 = executor.submit(c1);System.out.println(f4.get());Future f5 = executor.submit(c2);System.out.println(f5.get()); 执行结果12344null5result2","tags":[{"name":"java","slug":"java","permalink":"http://www.yuanyang-miemie.win/tags/java/"}]},{"title":"Java 线程池","date":"2018-03-12T07:31:01.000Z","path":"2018/03/12/Java线程池/","text":"使用线程池的优点 降低资源消耗。通过反复利用已创建的线程降低创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建好就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 线程池主要工作原理 线程池的使用创建线程池可以通过ThreadPoolExecutor来创建一个线程池1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize(线程池的基本大小):当提交一个任务到线程池，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。 runnableTaskQueue(任务队列):用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，按FIFO原则对元素进行排序 LinkedBlockingQueue：一个基于链表结构的阻塞队列，按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchrinousQueue:一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作会一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 maximumPoolSize(线程池最大数量):线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用了无限队列，则这个参数就没有效果。 ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来线程设置有意义的名字。 1new ThreadFactoryBuilder().setNameFormat(&quot;XX-task-%d&quot;).build(); RejectedExecutorHandler(饱和策略):当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。 AbortPolocy：直接抛出异常（默认） CallerRunsPolicy：只用调用所在线程来运行任务 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务 DiscardPolicy：不处理，丢弃掉 向线程池提交任务可以使用两个方法向线程池提交任务，分别为execute()和submit()方法 execute()方法用于提交不需要返回的任务，所以无法判断任务是否执行成功。submit()方法用于提交需要返回值的任务，线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功。 关闭线程池可以调用线程池的shutdown或shutdownNow方法来关闭线程池。 相同点：它们都是通过遍历线程池中的线程，然后逐个调用线程的interrupt方法来中断线程。 不同点：shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了这两个关闭方法中的一个，isShutdown方法就会返回为true。当所有任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法才会返回true。","tags":[{"name":"java","slug":"java","permalink":"http://www.yuanyang-miemie.win/tags/java/"}]},{"title":"Java8函数式编程学习笔记(初探)","date":"2017-09-07T06:43:00.000Z","path":"2017/09/07/Java8函数式编程学习笔记(初探)/","text":"编程语言的整个目的就在于操作值,要是按照历史上编程语言的传统,这些值被成为一等值,而编程语言中的其他结构也许有助于表示值的结构,但在程序执行期间不能传递,因此为二等值,比如方法和类等则是二等值,类可以实例化来产生值,但方法和类本身都不是值,java8的设计者则决定允许方法作为值,让编程更轻松. 举个栗子就农场库存程序而言,如果要实现一个从列表中塞选出绿色苹果的功能,可能会这样写(1.0)123456789public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) &#123; if (&quot;green&quot;.equals(apple.getColor()))&#123; result.add(apple); &#125; &#125; return result; &#125; 假如这个时候要赛选出不仅是绿色的苹果,可能会加入一个颜色作为参数,就象这样(2.0)123456789public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory, String color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) &#123; if (color.equals(apple.getColor()))&#123; result.add(apple); &#125; &#125; return result; &#125; 但这个时候别人可能还想区分出重苹果和轻苹果,你可能会这样来赛选重苹果123456789public static List&lt;Apple&gt; filterApplesByWeight(List&lt;Apple&gt; inventory, int weight)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory)&#123; if (apple.getWeight() &gt; weight) &#123; result.add(apple); &#125; &#125; return result; &#125; 这样解决确实不错,但是却复制了大量的代码来实现功能,它打破了DRY(Don’t Repeat Yourself)的软件工程原则,会许这时候你可能会将两种条件结合起来,并用一个标识表示赛选那种类型的苹果,像这样(3.0)123456789public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory, String color, Integer weight, boolean flag)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory)&#123; if ((flag &amp;&amp; apple.getColor().equals(color)) || (!flag &amp;&amp; apple.getWeight() &gt; weight)) &#123; result.add(apple); &#125; &#125; return result; &#125; 但是,这并不是一个可行的解决方案,首先别人阅读你的代码的时候,true|false表示什么?如果这个时候还有更加复杂的塞选情况又该怎么办?java8的行为化参数可以解决这个问题 行为参数化让方法接受多种行为(或战略)作为参数,并在内部使用,来完成不同的行为. 好处: 多种行为,一个参数,可以把迭代要塞选的集合的逻辑和对集合中每个元素应用的行为区分开来,这样可以重复使用同一个方法,给他不同的行为达到不同的目的. 定义一个接口来对选择标准建模123public interface ApplePredicate &#123; boolean test (Apple apple);&#125; 现在就可以为它进行多个实现了,比如123456789101112131415public class AppleGreenColorPredicate implements ApplePredicate &#123; @Override public boolean test(Apple apple) &#123; //仅选出绿色的苹果 return &quot;green&quot;.equals(apple.getColor()); &#125;&#125;public class AppleHeavyWeightPredicate implements ApplePredicate &#123; @Override public boolean test(Apple apple) &#123; //仅选出重的苹果 return apple.getWeight() &gt; 150; &#125;&#125; 现在经过java8的改良,代码可能会是这个样子(4.0)123456789public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; apples, ApplePredicate predicate)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : apples)&#123; if (predicate.test(apple))&#123; result.add(apple); &#125; &#125; return result; &#125; 每次调用的时候,只需要传递相应的行为即可,比如1List&lt;Apple&gt; greenApples = filterApples(inventory,new AppleGreenColorPredicate()); 这样一来,每次塞选的是什么苹果完全取决于通过ApplePredicate对象传递的代码,换句话说,把filterApple的方法行为参数化了 当然,到了这里你可能还觉得不甘心,因为每次都要去创建一个新的类,有点啰嗦,所以,你可以使用匿名类来完成这一工作(5.0)123456List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return &quot;red&quot;.equals(apple.getColor()); &#125;&#125;); 但是,匿名类还是不够还,因为它占用了很多空间,所以,在java8中可以直接使用Lambda表达式来完成(6.0)1List&lt;Apple&gt; weightApples = filterApples(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150); 到目前为止,总算是可以解决啰嗦麻烦的问题了,因为它更像在描述问题本身.现在你可以将List抽象画,让他应用面更加广泛12345678910111213public interface Predicate&lt;T&gt;&#123; boolean test(T t);&#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)&#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T e : list)&#123; if(p.test(e))&#123; result.add(e); &#125; &#125; return result;&#125; 现在在灵活性和简洁性之间找到了平衡点,这是java8带来的便利.","tags":[{"name":"Java","slug":"Java","permalink":"http://www.yuanyang-miemie.win/tags/Java/"}]},{"title":"Linux系统部署Web项目与问题分享","date":"2017-07-08T14:43:00.000Z","path":"2017/07/08/Linux系统部署Web项目/","text":"首先,需要有java环境和tomcat服务器,至于这个怎么安装,可以参考:云服务器 java+tomcat 部署与配置 项目部署有两个大步骤: Step1将已经写好的web项目打包成war包,在IDEA中使用Maven项目时,可以直接在pom.xml中指定打包方式为war,在target目录中可以找到对应的war包文件1&lt;packaging&gt;war&lt;/packaging&gt; Step2将打包好的*.war文件用文件传输工具上传到Linux系统中的Tomcat服务器的webapps文件夹中,上传之后,Tomcat会自动帮我们部署项目,接下来就可以访问了. 例如:按上面文章所采用的方法,需要把war包放到/usr/local/java/tomcat9/webapps文件夹下 之后就可以通过http://host:port/content来访问项目了 例如:有一个test项目1http://39.39.39.39:8080/test/index.html 我在部署中遇见这样一个问题: 我的mysql数据库设置了一个普通用户yy,拥有这个项目所使用数据库的所有权限,但是通过项目连接数据库怎么也连不上,直接通过用户在黑框框里登录是可以的,我到Linux系统中查看日志文件(方法见底),发现报出的错误为 我当时都惊了,我jdbc.properties文件里面不是用的root用户,为什么会报这个错误呢,原因在哪儿? 这个错误不是在远程连接的时候没有权限被拒的错误吗?所以我就试着给root用户授权1grant all privileges on *.* on &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option; 授权之后惊人的一幕出现了,这个时候可以用项目中的用户访问数据库了,我觉得非常奇怪,后来我为了证明这个问题,我删除了root用户的这些授权,这个时候yy仍然可以通过项目连接到数据库,并没有受root用户的影响,可是之前有受到了影响, 但是,第二天访问网站的时候,又不可以连接数据库了,还是上面这个错误,原因到底在哪儿?我现在还没有答案. 查看日志的方法如下:首先进入到tomcat服务器的logs目录,输入下面的命令就可以实时跟踪日志,ctrl+c即可退出1tail -f catalina.out","tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://www.yuanyang-miemie.win/tags/小技巧/"},{"name":"项目取经","slug":"项目取经","permalink":"http://www.yuanyang-miemie.win/tags/项目取经/"}]},{"title":"云服务器 java+tomcat 部署与配置","date":"2017-06-12T07:31:01.000Z","path":"2017/06/12/云服务器 java+tomcat 部署与配置/","text":"安装之前首先下载 tomcat java 文件上传工具FileZilla 选择合适的版本压缩包(*.tar.gz)进行下载,或者到百度云盘进行下载 安装Java JDK8.0建立java目录，存放jdk和tomcat12cd /usr/local/mkdir java 使用FileZilla将下载好的jdk-8u101-linux-x64.tar.gz和 apache-tomcat-9.0.0.M10.tar.gz上传至刚才建立的java目录下,至于怎么使用,百度经验妥妥的. 将上传的jdk解压，然后重命名为jdk12tar -zxv -f jdk-8u101-linux-x64.tar.gzmv jdk1.8.0_101 jdk 如果不清楚解压后的文件名,可以输入命令ls查看 配置环境变量1vim /etc/profile 打开文件之后按键盘i进入编辑模式,将下面的内容复制到底部1234JAVA_HOME=/usr/local/java/jdkPATH=$JAVA_HOME/bin:$PATHCLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jarexport PATH JAVA_HOME CLASSPATH 输入完毕后,按ESC退出输入模式,然后直接输入:wq回车,保存并且关闭Vim。 使用source /etc/profile命令使其立即生效通过java -version验证java环境是否配置成功。 安装Tomcat9.0解压Tomcat9.0,重命名为tomcat912tar -zxv -f apache-tomcat-9.0.0.M10.tar.gzmv apache-tomcat-9.0.0.M10 tomcat9 解压完毕后即可直接启动 启动命令为: /usr/local/java/tomcat9/bin/startup.sh 关闭命令为: /usr/local/java/tomcat9/bin/shutdown.sh 启动完成后还需开放8080端口1firewall-cmd --zone=public --add-port=8080/tcp --permanent 出现success表明添加成功 然后更新防火墙即可：firewall-cmd --reload 重启防火墙命令: systemctl restart firewalld.service 然后再次在浏览器中输入http://ip:8080，如果看到tomcat的欢迎界面，说明安装成功。 如果还不能访问,则有可能是云服务器没有设置对应的安全组,则需在安全组的设置里加入一条8080端口的访问规则. 小妙招如果你的java和tomcat都安装成功了,那么接下来你会想,每次都这样进行tomcat的启动和关闭,是不是有点麻烦? 那么可以通过一个脚本来帮我们实现命令启动tomcat 创建脚本执行代码：vi etc/init.d/tomcat按i进入编辑,将以下内容输入进入,按ESC退出编辑并输入:wq保存并退出Vim1234567891011121314151617181920212223242526272829# !/bin/bash # Description: start or stop the tomcat # Usage: tomcat [start|stop|restart] # export PATH=$PATH:$HOME/bin export BASH_ENV=$HOME/.bashrc export USERNAME=&quot;root&quot; case &quot;$1&quot; in start) #startup the tomcat cd /usr/local/java/tomcat9/bin ./startup.sh ;; stop) # stop tomcat cd /usr/local/java/tomcat9/bin./shutdown.sh echo &quot;Tomcat Stoped&quot; ;; restart) $0 stop $0 start ;; *) echo &quot;tomcat: usage: tomcat [start|stop|restart]&quot; exit 1 esac exit 0 为脚本添加执行权限执行命令:chmod +x /etc/init.d/tomcat 创建软连接依次执行如下命令12cd usr/binln -s /etc/init.d/tomcat 测试这样,我们就可以分别使用命令123tomcat starttomcat stoptomcat restart 来进行服务器的启动、关闭和重启操作了","tags":[{"name":"java","slug":"java","permalink":"http://www.yuanyang-miemie.win/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"http://www.yuanyang-miemie.win/tags/tomcat/"},{"name":"Lunix","slug":"Lunix","permalink":"http://www.yuanyang-miemie.win/tags/Lunix/"}]},{"title":"applicationContext.xml 解析详细-Spring源码学习之XML文件的初解析","date":"2017-05-11T16:23:01.000Z","path":"2017/05/12/applicationContext.xml 解析详细-Spring源码学习之XML文件的初解析/","text":"首先,在我的这篇博客中已经说到容器是怎么初步实现的,并且要使用XmlBeanDefinitionReader对象对Xml文件进行解析,那么Xml文件是如何进行解析的,将在这片博客中进行一些陈述. 数据准备阶段准备的目的是封装resource参数,目的是为了考虑到Resource可能存在编码要求的情况,其次,通过SAX读取XML文件的方式来准备InputSource对象,最后将参数传递到最核心的实现部分doLoadBeanDefinitions(inputSource,encodedResource.getResource()) 封装Resource调用XmlBeanDefinitionReader的loadBeanDefinitions(Resource resource)方法时,首先将resource对象进行再次封装成EncodedResource,查看源码可以发现里面增加了字符集和编码的封装,从命名上来看也可以体现出来,将资源封装完成后,就调用重载的同名函数loadBeanDefinitions(EncodedResource resource)进行正式的解析. 数据准备操作在重载方法里面首先通过Set&lt;!-- &lt;EncodedResource&gt; --&gt; currentResources属性来记录已经加载的资源,其次,从EncodedResource对象中获取封装好的Resource对象,并获取其inputStream,将获取到的输入流与SAX解析的InputSource绑定,接下来就进入到了核心的实现部分:doLoadBeanDefinitions(inputSource,encodedResource.getResource()) 核心实现核心部分有两个关键步骤: 调用doLoadDocument(inputSource.resource)方法获取Document 根据返回的Document信息注册Bean信息 这两个步骤支持着整个Spring容器部分的实现基础 获取Document进入方法体后,将Document的创建交给DefaultDocumentLoader documentLoader属性的loadDocument()方法,该方法声明如下:1234Document loadDocument( InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception; 调用情况:12documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware()) InputSource:SAX解析需要使用到的对象 EntityResolver:它的作用是项目本身就可以提供一个如何寻找DTD声明的方法,由程序来实现寻找DTD声明的过程,将DTD文件放到项目中某处,在实现时直接将此文档读取并返回给SAX即可,避免了必须通过网络来寻找相应的声明. 在这个接口中定义了一个方法12InputSource resolveEntity (String publicId,String systemId) throws SAXException, IOException; 如果解析的验证模式是XSD:1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&gt; 那么.此时得到的两个参数值分别是: publicId:nullsystemId:http://www.springframework.org/schema/beans/spring-beans.xsd 如果解析的验证模式是DTD:12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE beans PUBLIC &quot;-//Spring//DTD BEAN 2.0//EN&quot; &quot;http://www.Springframework.org/dtd/Spring-beans-2.0.dtd&quot; 那么,此时得到的两个参数值分别是: publicId:-//Spring//DTD BEAN 2.0//ENsystemId:http://www.Springframework.org/dtd/Spring-beans-2.0.dtd 而对于不同的验证模式,Spring使用了不同的解析器,当使用DTD验证时,Spring会截取后面的*.dtd,并直接到当前目录去寻找,当使用XSD验证时,Spring会到META-INF/Spring.schemas文件中去匹配相应的systemId并加载对应的XSD文件 validationMode:验证模式 首先,为了保证XML文件的正确性,有常见两种验证模式:DTD、XSD 两种验证模式的区别我对这两种的区别目前还不是很详细,只能简略的给出定义,但我看到的最直观的区别是,DTD验证需要单独写出一个标签&lt;!DOCTYPE ...&gt;,而XSD验证会将信息写入&lt;beans xmlns=&quot;...&quot;&gt;结点 DTDDTD(Document Type Definition)即文档类型定义,是一种保证XML文档格式正确的有效方法,可以通过比较XML文档和DTD文件来看文档是否符合规范. XSDXML Schema语言就是XSD(XML Schema Definition),描述了XML文档的结构,可以用一个指定的XML Schema来验证XML文档,以检查文档是否符合要求. 验证模式的读取验证模式的读取非常简单,在getValidationModeForResource(resource)方法中先获取当前设定的验证模式是不是自动选择,源码中是这么解释的since we cannot find a clear indication,当找不到一个确切的验证模式时,采用这种方式,然后判断当前resource对象中采用的是什么验证模式,通过检索字符串的方式,当存在DOCTYPE的时候,就采用DTD验证模式,否则采用XSD验证模式 namespaceAware:一个布尔值,默认为false,在前面可以看到,在使用XSD验证的时候会有xmlns=&quot;&quot;,其实就是XML namespace的缩写,可以有多个命名空间,如果使用的是XSD解析,将会把这个值改为true 解析并注册BeanDefinitions在上一步得到Docment对象之后,调用registerBeanDefinitions(Document doc,Resource resource)12345678910public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; //创建对象 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //记录当前已经加载的数量 int countBefore = getRegistry().getBeanDefinitionCount(); //加载并注册 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //返回本次加载的个数 return getRegistry().getBeanDefinitionCount() - countBefore; &#125; 而在调用documentReader对象方法中,才开始进行正式的解析工作123456public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root); &#125; 解析的工作全权交给doRegisterBeanDefinition(root)方法实现,这样XML文件就正式进入了解析步骤,至于怎么解析的,博主将慢慢学习并写入后续博客.","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yuanyang-miemie.win/tags/学习笔记/"},{"name":"Spring源码","slug":"Spring源码","permalink":"http://www.yuanyang-miemie.win/tags/Spring源码/"}]},{"title":"BeanFactory与ApplicationContext的区别-Spring源码学习之容器的基本实现","date":"2017-05-05T03:30:14.000Z","path":"2017/05/05/BeanFactory与ApplicationContext的区别-Spring源码学习之容器的基本实现/","text":"可以加载XML两种方法使用 BeanFactory 加载 XML1BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;applicaitonContext.xml&quot;)); Ps:因为我是跟着《Spring源码深度解析》学习的,而这本书出版在13年9月,这一种方法在新的Spring版本中已经废弃掉了,取而代之的是下面的方法;但既然学了,那就还是记录一下,学习一下开发者的思想也是不错的. 使用 ApplicationContext 加载 XML1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 相同点上述两者都是通过加载XMl配置文件的方式加载Bean,而后者是前者的扩展,提供了更多的功能,即ApplicationContext拥有BeanFactory的全部功能,在绝大多数的”典型的”企业应用和系统,ApplicationContext都优先于BeanFactory. 不同点BeanFactory是延迟加载,如果一个Bean当中存在属性没有加载,会在第一次调用getBean()方法的时候报错,而ApplicationContext会在读取Xml文件后,如果配置文件没有错误,就会将所有的Bean加载到内存中,缺点就是在Bean较多的时候比较占内存,程序启动较慢. Spring容器加载中最重要的两个类DefaultListableBeanFactoryXmlBeanFactory继承自DefaultListableBeanFactory,而后者是整个Bean加载的核心部分,是Spring注册及加载Bean的默认实现,而XmlBeanFactory使用了自定义的Xml读取器XmlBeanDefinitionReader,实现了个性化的BeanDefinitionReader读取. XmlBeanDefinitionReader主要负责Xml文件的读取、解析和注册功能 加载时的区别上面的两种方法的处理大致相同,让我们通过时序图看看两者在加载时的区别: 1BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;applicaitonContext.xml&quot;)); 粗略时序图: 首先,将applicationContext.xml用ClassPathResource进行封装得到Resource资源,Resource接口将所有的资源文件统一处理,当通过Resource相关类完成了对配置文件的封装之后,就由XmlBeanDefinitionReader进行读取和解析. 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 粗略时序图: 附上ClassPathXmlApplicatioContext构造函数的源码:123456789101112public ClassPathXmlApplicationContext(String[] paths, Class&lt;?&gt; clazz, ApplicationContext parent) throws BeansException &#123; super(parent); Assert.notNull(paths, &quot;Path array must not be null&quot;); Assert.notNull(clazz, &quot;Class argument must not be null&quot;); this.configResources = new Resource[paths.length]; //创建资源数组 private Resource[] configResources; for (int i = 0; i &lt; paths.length; i++) &#123; this.configResources[i] = new ClassPathResource(paths[i], clazz); &#125; refresh(); //解析工作,ClassPathXmlApplicatioContext继承来自AbstractApplicationContext中的方法 &#125; 首先,同样是封装配置文件,但封装完成之后并没有直接进行读取,而是调用了refresh()方法(这个方法里面进行了很多操作,扩展的功能几乎是在这里面实现的),refresh()方法中的obtainFreshBeanFactory()方法负责初始化BeanFactory,并对XMl文件读取,读取的核心实现是该方法中调用的refreshBeanFactory()方法,这个方法再调用图中的loadBeanDefinitions(beanFactory)方法(由于板面原因,没有画出),然后在其中创建XmlBeanDefinitionReader对象,再将最初封装的资源文件数组进行依次读取并解析. 二者在后面的Xml解析工作都几乎是一样的,都采用了SAX解析,区别就在于解析之前的准备和解析之后的完善工作.","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.yuanyang-miemie.win/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yuanyang-miemie.win/tags/学习笔记/"}]},{"title":"CentOS7-MySQL安装与远程访问","date":"2017-05-03T13:31:01.000Z","path":"2017/05/03/CentOS7-MySQL安装与远程访问/","text":"本人乃学生小白一枚,近期在学习Linux,所以就简单记录一下~ 安装MySQL检查首先,需要检查一下是否已经安装了MySQL : # rpm -qa | grep mysql 这时候没有任何输出,则代表没有安装MySQL 下载源CentOS7的yum源中没有自带的MySQL安装程序,所以要手动下载 1# wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 安装源安装刚才下载的mysql-community-release-el7-5.noarch.rpm 1# rpm -ivh mysql-community-release-el7-5.noarch.rpm 正式安装MySQL 安装 # yum install mysql-server 重启服务 等待安装完成后,重启MySQL服务: # service mysqld restart 设置密码 新安装的MySQL是没有密码的,下面进行密码设置 输入# mysql -uroot可以直接登录,设置密码的时候,一定记得用password()函数加密123mysql&gt; set password = password(&apos;yourPassword&apos;);ormysql&gt; update user set password = password(&apos;yourPassword&apos;) where user = &apos;root&apos;; 修改完成后退出MySQL重启服务就可以了.(\\q、quit、exit都可以退出) 远程访问本人使用的腾讯云服务器 设置用户首先,远程访问需要设置一个允许远程访问的用户,root用户默认是不允许远程访问的1mysql&gt; grant all privileges on *.* to &apos;yy&apos;@&apos;%&apos; identified by &apos;password&apos; 授予yy用户所有访问权限,*.*代表任意数据库的任意表,%代表任意ip地址,通过password密码来访问(这里也可以直接授予root用户这种权限) 授权完成后刷新一下 : mysql&gt; flush privileges; 其次,需要开放3306端口1# firewall-cmd --zone=public --add-port=3306/tcp --permanent 出现success即开放成功,然后重启防火墙1# systemctl restart firewalld.service 设置安全组然后,需要设置一个安全组,在安全组的规则里面必须开放3306端口 这些工作作完之后,就可以开始尝试连接了 我在连接的时候遇到了下面的问题,连接失败了 我当时想到是 网络问题,使用ping命令查看能否ping通 端口问题,检查了端口是否开放 服务器问题,查看MySQL服务是否开启 安全组设置问题,检查一下安全组的设置 然而呢,都不是这些问题,我也搜索了很久,最后被我发现了,是我安全组设置完了之后,没有关联实例!没有关联实例!没有关联实例!重要的事情说三遍. 以上就是我简单的学习记录.","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yuanyang-miemie.win/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://www.yuanyang-miemie.win/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.yuanyang-miemie.win/tags/MySQL/"}]},{"title":"《Spring 实战》-- Spring Web Flow 学习笔记","date":"2017-04-27T07:31:01.000Z","path":"2017/04/27/Spring Web Flow 学习笔记--披萨流程/","text":"Spring Web Flow是Spring MVC的扩展,它支持开发基于流程的应用程序.它将流程的定义与实现流程行为的类和视图分离开来. 在Spring中配置Web Flow Spring Web Flow是构建于Spring MVC的基础上的,这意味着所有的流程请求都需要首先经过DispatcherServlet.我们需要在Spring应用上下文中配置一些Bean来处理流程并执行请求. 首先,我们在Spring的基础上会多使用到4个jar包,并且会使用到flow命名空间 配置做好了准备工作,让我们一起来看一下配置 装配流程执行器在Spring配置文件中使用&lt;flow:flow-executor&gt;元素创建一个流程执行器. 正如其名,流程执行器驱动流程的执行,用户进入一个流程时,流程执行器会为用户创建并启动一个流程执行实例,当流程暂停的时候(如为用户展示视图时),流程执行器会在用户执行操作后恢复流程.流程执行器只负责创建和执行流程,但它并不负责加载流程定义.这个任务由流程注册表完成 1&lt;flow:flow-executor id=&quot;flowExecutor&quot;/&gt; 配置流程注册表在Spring配置文件中使用&lt;flow:flow-register&gt;配置流程注册表,流程注册表的工作是加载定义并让流程执行器能够使用它们. 123&lt;flow:flow-registry id=&quot;flowRegistry&quot; base-path=&quot;/WEB-INF/flows&quot;&gt; &lt;flow:flow-location-pattern value=&quot;/**/*-flow.xml&quot; /&gt;&lt;/flow:flow-registry&gt; 如果不使用通配符,这里也可以使用&lt;flow:flow-location id=&quot;pizza&quot; path=&quot;/WEN-INF/flows/springpizza.xml&quot;/&gt;来指定流程配置文件的详细位置,当不显示指定id时,以文件名作为id的值 处理流程请求在Spring MVC的基础上,还需要一个FlowHandlerMapping来帮助DispatcherServlet发送流程请求给spring web flow,在Spring的上下文中添加如下配置 123&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerMapping&quot;&gt; &lt;property name=&quot;flowRegistry&quot; ref=&quot;flowRegistry&quot; /&gt; &lt;/bean&gt; 可以看到,它装配了流程注册表的引用,这样它就能知道如何将请求的URL匹配到流程上 FlowHandlerMapping仅是对流程请求的处理,响应请求由FlowHandlerAdapter处理,它会把响应发送的流程请求进行处理,在Spring的上下文中添加如下配置: 123&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter&quot;&gt; &lt;property name=&quot;flowExecutor&quot; ref=&quot;flowExecutor&quot; /&gt;&lt;/bean&gt; 这样,所有的准备工作都已经做完了!但这还不够,在定义流程前,我们先来看一下流程组件 流程组件在Spring Web Flow中,流程是由三个主要元素定义的:状态、转移和流程数据. 状态(state)即流程中事件的发生地点,如果将流程比喻成公路旅行,那么状态就是路途上的城镇或风景点,一共有五种不同的状态 状态类型 作用 行为(action) 行为状态是流程逻辑发生的地方 决策(decision) 决策状态将流程分成两个方向,它会基于流程数据的评估结果确定流程方向 结果(end) 结束状态是流程的最后一站,一旦进入End状态,流程就会终止 子流程(subflow) 子流程状态会在当前正在运行的流程上下文中启动一个心的流程 视图(view) 视图状态会暂停流程并邀请用户参与流程 视图状态 视图状态用于为用户展现信息并使用户在流程中发挥作用,可以是任意Spring支持的视图类型.在下面的示例中,id在流程内标识这个状态,当不使用view显示指定另一个视图名称时,它也代表视图的名称,model指明表单所绑定的对象1&lt;view-state id=&quot;welcome&quot; view=&quot;greeting&quot; model=&quot;flowScope.paymentDetails&quot;/&gt; 行为状态 行为状态是应用程序自身在执行任务,行为状态一般会触发Spring所管理的Bean的一些方法并根据方法调用的执行结果转移到另一个状态.如下例,其中的evaluate子节点代表行为状态要做的事,在此处它会找到id为pizzaFlowActions的bean并执行saveOrder()方法1234&lt;action-state id=&quot;saveOrder&quot;&gt; &lt;evaluate expression=&quot;pizzaFlowActions.saveOrder(order)&quot; /&gt; &lt;transition to=&quot;thankYou&quot; /&gt;&lt;/action-state&gt; 决策状态 决策状态能够在流程执行时产生两个分支.决策状态将评估一个Boolean类型的表达式,然后在两个状态中选择转移一个.可以看到,if子节点是这个状体的核心,test中的表达式值为true则转移到then指定状态,否则转移到else指定状态12345&lt;decision-state id=&quot;checkDeliveryArea&quot;&gt; &lt;if test=&quot;pizzaFlowActions.checkDeliveryArea(order.customer.zipCode)&quot; then=&quot;addCustomer&quot; else=&quot;deliveryWarning&quot;/&gt;&lt;/decision-state&gt; 子流程状态 就像把代码逻辑分写到多个类/方法中一样,流程也将其分成一些子流程.如下例中子流程结束的&lt;endstate&gt;的id为orderCreated,则流程将会进入到名为payment的状态1234&lt;subflow-state id=&quot;customer&quot; subflow=&quot;pizza/customer&quot;&gt; &lt;input name=&quot;order&quot; value=&quot;order&quot;/&gt; &lt;transition on=&quot;customerReady&quot; to=&quot;order&quot; /&gt;&lt;/subflow-state&gt; 结束状态 所有的流程均会结束,这就是结束状态要做的事情.1&lt;end-state id=&quot;customerReady&quot;&gt; 在流程结束后,接下来会发生什么取决于以下因素: 如果结束流程是一个子流程,那么调用它的流程将会从&lt;subflow-state&gt;处继续执行,&lt;end-state&gt;的id将会用作事件触发从&lt;subflow-state&gt;开始的转移 如果&lt;end-state&gt;设置了view属性,指定的视图将会被渲染.视图可以是相对于流程路径的视图模版,如果添加externalRedirect:前缀话,将会重定向到流程外部的页面,如果添加flowRedirect:将会重定向到另一个流程中 如果结束的流程不是子流程,也没有指定view属性,那这个流程只是会结束而已,浏览器最后将会加载流程的基本URl地址,当前已没有活动的流程,所以会开始一个新的流程实例 ==流程可能会有不止一个结束状态,子流程的结束状态id确定了激活的事件,所以可以通过多钟结束状态来结束子流程,从而能够在流程中触发不同的事件,即使不是在子流程中,在结束流程后也可以根据流程的执行情况进行多个页面的选择== 转移流程中除结束状态之外的每个状态都至少需要一个转移,使用&lt;transition&gt;子节点来定义,在前面可能你已经看到了他的身影.它是action-state/view-state/subflow-state的子节点,其中id可以是用户触发的事件,在子流程中,事件取决于子流程结束的id,任何事件都可以使用no来触发转移事件,当抛出异常时,可以使用on-exception来指定异常的转移状态.1&lt;transition to=&quot;lookupCustomer&quot; id=&quot;phoneEntered&quot;/&gt; 全局转移:在多个状态中都需要用到的转移,可以定义成全局转移123&lt;global-transitions&gt; &lt;transition on=&quot;cancel&quot; to=&quot;endState&quot; /&gt;&lt;/global-transitions&gt; 流程数据 定义变量 流程数据保存在变量中,而变量可以在流程的各个地方进行引用,它能够以多钟方式创建,在流程中创建变量的最简单形式就是使用&lt;var&gt;元素1&lt;var name=&quot;order&quot; class=&quot;com.springinaction.pizza.domain.Order&quot;/&gt; 当然,也可以使用&lt;evaluate&gt;元素计算并创建一个变量12&lt;evaluate result=&quot;viewScope.toppingsList&quot; expression=&quot;T(com.springinaction.pizza.domain.Topping).asList()&quot; /&gt; 也可以使用&lt;set&gt;元素设置变量的值12&lt;set name=&quot;flowScope.pizza&quot; value=&quot;new com.springinaction.pizza.domain.Pizza()&quot; /&gt; 后面两个特别类似,都是通过计算生成结果 流程数据的作用域 范围 作用域与可见性 Conversation 最高层级的流程开始创建,在最高层级的流程结束时销毁,被最高层级的流程与子流程共享 Flow 当流程开始时创建,在流程结束时被销毁,只有在创建它的流程中是可见的 Request 当一个请求进入流程的时候创建,在流程返回时被销毁 Flash 当流程开始的时候创建,在流程结束的时候销毁,在视图状态渲染后,它也会被清除 View 当进入视图状态时创建,当这个状态退出的时候销毁,只在视图状态内可见 当使用&lt;var&gt;元素声明时,变量始终是流程作用域的,当使用&lt;set&gt;或&lt;evaluate&gt;的时候,作用域通过name或result属性的前缀指定 以上就是Spring Web Flow 的基础知识,至于Demo可以在《Spring 实战》的指定网站上下载源码,当然啦,也可以百度一下,为了方便起见,可以直接去我建的仓库克隆一下,传送门,这是Spring Web Flow的Demo ,不是全部的源码.","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.yuanyang-miemie.win/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yuanyang-miemie.win/tags/学习笔记/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.yuanyang-miemie.win/tags/Spring-MVC/"}]},{"title":"Spring MVC 搭建 - Hello world","date":"2017-04-27T07:31:01.000Z","path":"2017/04/27/Spring MVC 搭建/","text":"现在的Web框架基本都采用了MVC(model-view-Controller)设计模式,其中,Servlet和Filter都可以充当控制器.Spring MVC采用一个Servlet作为控制器,而Struts2则采用的Filter作为控制器. 对于他们的区别我在这里不多赘述,可以参见这篇文章SpringMVC与Struts2区别与比较总结 Spring MVC的搭建可以通过Java代码的方式(在《Spring 实战》一书中有详细讲解),也可以通过配置文件的方式,这里讲到的是运用配置文件的方式进行搭建. 这是一个毫无技术含量的最简单例子 使用工具 idea maven 当然啦~如果你不想使用Maven可以直接跳过前两步 Demo结构 搭建一个Web项目可以参见Idea 使用 Maven 搭建 Web 项目 添加依赖123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置classpath12345678910111213141516&lt;build&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;!--配置Classpath--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 配置web.xml123456789101112131415161718192021222324252627&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;&lt;web-app&gt; &lt;!--spring的配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring MVC必须的servlet,他会帮你把Spring的配置文件到application域中--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--Spring MVC的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置applicationContext.xml1&lt;context:component-scan base-package=&quot;com.geek&quot;/&gt; 配置dispatcher-servlet.xml 12345678910&lt;!--启动Spring MVC的注解--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--自动扫描包--&gt;&lt;context:component-scan base-package=&quot;com.geek&quot;/&gt;&lt;!--视图解析器--&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; &lt;mvc:annotation-driven/&gt;这句话非常关键!如果不写会导致@Controller注解不能使用 测试TestController.java1234567891011121314@Controllerpublic class TestController &#123; @Autowired private TestService service; @RequestMapping(&quot;/test&quot;) public String Test(String s, HttpServletRequest request)&#123; service.show(); request.setAttribute(&quot;s&quot;,s); return &quot;index&quot;;//由于前面配置了视图解析器,此处会跳转到index.jsp页面 &#125;&#125; 在这里使用了@Controller注解,逻辑上标志着这个类是一个控制器,让编程过程中更容易理解其中的@RequestMapping(&quot;/test&quot;)指将这个url(localhost:8080/test)映射到此方法上,在Spring MVC中以一个方法为上下文进行拦截. TestService.java12345678@Servicepublic class TestService &#123; public void show()&#123; System.out.println(&quot;success&quot;); &#125;&#125; index.jsp123456789&lt;%@page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html&quot;%&gt;&lt;html&gt;&lt;body&gt;&lt;% String s = (String) request.getAttribute(&quot;s&quot;); out.print(s!=null?s:&quot;hello&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器输入 http://localhost:8080/test?s=123456 可以看到控制台打印success,index.jsp页面的显示由hello变为123456 这样,Spring MVC 的一个小Demo就算完成了,当然,这里面使用了Spring的自动装配,整体上非常的简单例子,动手试试吧~","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.yuanyang-miemie.win/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yuanyang-miemie.win/tags/学习笔记/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.yuanyang-miemie.win/tags/Spring-MVC/"}]},{"title":"高性能Mysql学习笔记之事务","date":"2017-04-26T15:48:59.000Z","path":"2017/04/26/高性能Mysql学习笔记之事务/","text":"什么是事务?事务就是一组原子性的SQL查询,或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就会执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。简单的说，一个事务内的语句，要么全部执行成功，要么全部执行失败。 事务的ACID特性ACID表示事务的原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)。一个运行良好的事务处理系统，必须具备这些标准特性。 原子性(atomicity)一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能只执行其中的一部分操作。 一致性(consistency)数据库总是从一个一致性的状态换到另一个一致性的状态。 隔离性(isolation)通常来说：一个事务所做的修改在最终提交前,对其他事务是不可见的。 持久性(durability)一旦事务提交,则其所做的修改就会永久保存到数据库中。此时即使系统崩溃,修改的数据也不会丢失。 隔离级别READ UNCOMMITTED(读未提交)也叫==脏读==,在这个级别中,事务中的修改,即使没有提交,对其他事务也是可见的.一般都不采用. READ COMMITTED(读已提交)也叫==不可重复读==,因为两次相同的查询可能得到不同的结果.大多数数据库都默认使用这种隔离级别,一个事务从开始直到提交之前,所做的任何修改对其他事务都是不可见的. REPEATABLE READ(可重复读)==Mysql默认隔离级别==解决了==脏读==的问题,该级别保证了在同一个事务中多次读取同样的记录结果是一样的.但无法解决==幻读==的问题。幻读(Phantom Read),指当某个事务在读取某个范围内的记录时,另外一个事务又在该范围插入了新的记录,当之前的事务再次读取该范围的记录时,会产生换行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制解决了幻读问题。 SERIALIZABLE(可串行化)这是最高的隔离级别,它会通过强制事务串行执行,避免了前面说的幻读问题.简单地说SERIALIZABLE会在读取的每一行数据上都加上锁,所以可能导致大量的超时和争锁时间的问题.实际应用中也很少使用,只有在急需要保持数据一致且接受没有并发的情况下,才考虑使用. 隔离级别 脏读可能性 不可重复读可能性 幻读可能性 加锁读 READ UNCOMMITTED YES YES YES NO READ COMMITTED NO YES YES NO REPEATABLE NO NO YES NO SERIALIZABLE NO NO NO YES 死锁死锁是指两个或多个事务在同一个资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象.当多个事务试图以不同的顺序锁定资源时,就可能会产生死锁,多个事务同时锁定同一个资源时,也会产生死锁 例如: 事务1: 1234start transaction;update stock_price set close = 45.50 where stock_id = 4 and date = &apos;2017-4-26&apos;;update stock_price set close = 19.80 where stock_id = 3 and date = &apos;2017-4-27&apos;;commit; 事务2: 1234start transaction;update stock_price set high = 20.10 where stock_id = 3 and date = &apos;2017-4-27&apos;;update stock_price set high = 47.20 where stock_id = 4 and date = &apos;2017-4-26&apos;;commit; 如果凑巧,两个事务均执行了第一条update语句,同时锁定了该资源,当尝试执行第二条update语句的时候,去发现资源已经被锁定,两个事务都等待对方释放锁,则陷入死循环,形成死锁 为了解决这种问题,数据库系统实现了各种死锁检测和死锁超时机制.比如InnoDB存储引擎目前的处理方法是将持有最少级排他锁的事务进行回滚.","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yuanyang-miemie.win/tags/学习笔记/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.yuanyang-miemie.win/tags/Mysql/"}]},{"title":"Spring的声明式事务-Transactional","date":"2017-04-20T07:31:01.000Z","path":"2017/04/20/Transactional-Spring的声明式事务/","text":"Spring的声明式事务配置需要在xml文件中配置 1234567891011121314151617181920212223&lt;!--配置事务管理器类--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--这里的dataSource引用前边配置好的dataSource--&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--事务的建议--&gt;&lt;tx:advice id=&quot;interceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置事务切面--&gt;&lt;aop:config proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;&gt; &lt;!--切点为该包下的所有类的所有方法,任意返回值,任意参数--&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* geek.service.*.* (..))&quot;/&gt; &lt;!--在切点处加入事务--&gt; &lt;aop:advisor advice-ref=&quot;interceptor&quot; pointcut-ref=&quot;txPointCut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; tx:advice节点&lt;tx:advice.../&gt;节点详情如下图 name:指定方法的名称可以使用通配符 propagation:指定事务的传播行为,默认为为PROPAGATION_REQUIRED PROPAGATION_REQUIRED:要求在事务环境中执行该方法,如果当前执行线程已经处于事务环境中,则直接调用;如果当前线程不处于事务环境中,则启动新的事务后执行该方法. PROPAGATION_MANDATORY:要求调用该方法的线程必须处于事务中,否则抛出异常 PROPAGATION_NESTED:即使执行该方法的线程已经处于事务中们也依然启动新的事务,方法在嵌套的事务里执行;即使执行该方法的线程未处于事务环境中,也启动新的事务,然后执行该方法,此时与默认情况一致. PROPAGATION_NEVER:不允许调用该方法的线程处于事务环境中,如果调用该方法的线程处于事务环境中,则抛出异常 PROPAGATION_NOT_SUPPORTED:如果调用该方法的线程处于事务中,则先暂停当前事务,然后执行该方法 PROPAGATION_REQUIRED_NEW:该方法要求在新的事务环境中执行,如果当前执行线程已处于事务环境中,则先暂停当前事务,启动新的事务后执行该方法,如果当前线程不处于事务环境中,则启动新的事务后执行方法. PROPAGATION_SUPPORTS:如果当前线程处于事务环境中,则使用当前事务,否则不使用事务 isolation:指定事务的隔离级别 timeout:指定事务的超时时间 read-only:指定事务是否只读 rollback-for:指定触发事务回滚的异常类(全类名限定),可以指定多个,用英文逗号,隔开 no-rollback-for:指定不处罚事务回滚的异常类(全类名限定),可以指定多个,用英文逗号,隔开 @Transactional注解配置需要在xml文件里配置 123456&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--启动@Transactional注解--&gt;&lt;tx:annotation-driven transaction-manager = &quot;transactionManager&quot;/&gt; @Transactional注解即可以用于修饰Spring Bean类,也可以用于修饰Bean类中的某个方法 如果使用该注解修饰Bean类,表明这些事务设置对整个Bean起作用;如果使用该注解修饰Bean类的方法,则表明这些事务设置只对该方法有效。 @Transactional注解的属性 isolation:用于指定事物的隔离级别.默认为底层事务的隔离级别 noRollbackFor:用于指定遇到某个特定异常时强制不回滚事务 noRollbackForClassName:指定遇到特定的多个异常时强制不回滚事务,可以指定多个异常类名 propagation:指定事务的传播行为 readOnly:指定是否只读 rollbackFor:指定遇到特定异常时强制回滚事务 rollbackForClassName:指定遇到特定的多个异常时强制回滚事务.可以设置多个异常类名 timeout:指定事务的超时时长 @Transactional注解中所指定的属性与&lt;tx:advice.../&gt;元素中所指定的事务属性基本上是对应的。","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.yuanyang-miemie.win/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yuanyang-miemie.win/tags/学习笔记/"}]},{"title":"Idea-使用Mybatis-generator插件快速生成Mybatis相关代码","date":"2017-04-19T14:43:00.000Z","path":"2017/04/19/idea-使用Mybatis-generator插件快速生成Mybatis代码/","text":"使用这个插件可以快速生成一些代码,包含 实体类/Mapper接口/*Mapper.xml文件 项目要求首先,我们需要搭建一个Maven的项目,当然,这个项目必须要支持使用Mybatis。 修改pom.xml在pom.xml中添加代码1234567891011121314151617181920212223242526272829&lt;plugins&gt; &lt;plugin&gt; &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;yourLocation/mybatis-generator-config.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; 注意,plugins标签是build标签的子标签 配置mybatis-generator-config.xml添加好之后,我们就需要配置mybatis-generator-config.xml配置文件中的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration&gt; &lt;!-- 本地数据库驱动程序jar包的全路径 --&gt; &lt;classPathEntry location=&quot;&quot;/&gt; &lt;context id=&quot;context&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库的相关配置 --&gt; &lt;jdbcConnection driverClass=&quot;&quot; connectionURL=&quot;&quot; userId=&quot;&quot; password=&quot;&quot;/&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 实体类生成的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;目标包&quot; targetProject=&quot;目标项目classpath&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- *Mapper.xml 文件的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;目标包&quot; targetProject=&quot;目标项目classpath&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper 接口文件的位置 --&gt; &lt;javaClientGenerator targetPackage=&quot;目标包&quot; targetProject=&quot;目标项目classpath&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 相关表的配置 --&gt; &lt;table tableName=&quot;表名&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 随后,在idea的右侧栏点击Maven,选中添加的Mybatis-generator插件并运行,就可以得到相应的代码啦~ 是不是很简单啊? 那就快动手试试吧!","tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://www.yuanyang-miemie.win/tags/小技巧/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.yuanyang-miemie.win/tags/Mybatis/"},{"name":"随笔","slug":"随笔","permalink":"http://www.yuanyang-miemie.win/tags/随笔/"}]},{"title":"Idea 使用 Maven 搭建 Web 项目","date":"2017-03-28T07:31:01.000Z","path":"2017/03/28/Idea 使用 Maven 搭建 Web 项目/","text":"Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 使用它来搭建项目可以省去很多操作，它不仅有依赖管理、自动生成项目站点等超酷的特性，还可以让你从琐碎的手工劳动中解脱出来，帮你规范整个组织的构建系统。（可以通过《Maven 实战》一书进行详细学习） 搭建Web工程步骤创建新项目File-&gt;new-&gt;Project 选择 Maven 创建一个简单的 Web工程 输入唯一标识输入 GroupId 与 ArtifactId 用来唯一标识你的项目 添加变量添加一个变量,目的是为了让 Idea 创建 Maven 项目更快 输入项目名输入项目名称完成创建，并得到如下的目录 此时还并不算创建完毕，虽然添加服务器后可以运行，但还需要做一些简单的修饰 添加文件夹Ctrl+Alt+Shift+s 打开 Project Structure ，添加文件夹，并设置相应的功能模块 * main目录下添加一个 `java` 文件夹，设置为 `Sources` * src 目录下添加一个 `test` 文件夹,用于存放测试相关文件 * test 目录下添加一个 `java` 文件夹，设置为 `Tests` * test 目录下添加一个 `resources` 文件夹，设置为 `Test Resources` 配置Tomcat* 点击上面的按钮，`Edit Configurations...` * 点击 `+` 添加本地服务器 * 发布当前的项目 至此，Web 项目搭建完毕，就可以疯狂撸代码了，请开始你的表演~","tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://www.yuanyang-miemie.win/tags/小技巧/"}]},{"title":"idea + SSH框架整合","date":"2017-03-28T06:43:00.000Z","path":"2017/03/28/idea+SSH框架整合/","text":"Spring4 Struts2 Hibernate5 整合 是现在比较流行的一种开发方式，许多网站都使用了这种架构进行开发。那么怎么整合这三大框架？ 两个问题Spring 整合 Hibernate 整合什么？1) 由 `IOC` 容器管理 `Hibernagte` 的 `SessionFactory` 2) 让 `Hibernate` 使用上 `Spring` 的声明式事务 Spring 整合 Struts2 整合什么？1) 让 `Spring` 管理 `Struts2` 的 `Action` 首先用搭建一个Maven管理的Web项目，可以参考我的这篇博文:传送门 搭建完成之后，我们需要加入相关jar包并进行配置 相关设置添加jar包在pom.xml中添加jar包依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273&lt;dependencies&gt; &lt;!--Junit单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--添加hibernate的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.8.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.common&lt;/groupId&gt; &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt; &lt;version&gt;5.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.3.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.0.3.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.spec.javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jboss-transaction-api_1.2_spec&lt;/artifactId&gt; &lt;version&gt;1.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--依赖log4j slf4j--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Commons--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--配置Spring所需要的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--Struts2--&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-commons&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-tree&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.20.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ognl&lt;/groupId&gt; &lt;artifactId&gt;ognl&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.15.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts.xwork&lt;/groupId&gt; &lt;artifactId&gt;xwork-core&lt;/artifactId&gt; &lt;version&gt;2.3.15.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-Struts2整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!--aspectj--&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--配置jdbc所需要的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!--c3p0连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在pom.xml中设置classpath123456789101112131415&lt;build&gt; &lt;finalName&gt;ssh_demo&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 添加Hibernate配置文件 ctrl+alt+shift+s 打开 Project Structure 选择 Facets 添加 Hibernate 选择 Hibernate 点击右侧添加配置文件 找到配置文件，并添加简单的配置，数据源的配置在 Spring 中进行 12345678&lt;!--方言--&gt;&lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL57InnoDBDialect&lt;/property&gt;&lt;!--显示SQL--&gt;&lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;&lt;!--格式化SQL--&gt;&lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;&lt;!--生成表的策略--&gt;&lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; 添加Spring配置文件,并整合Hibernate 直接在Resources下添加Spring的配置文件 123456789101112131415161718192021222324252627282930313233343536&lt;!--配置数据源，请自定义取值--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt; &lt;/bean&gt;&lt;!--SessionFactory--&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappingLocations&quot; value=&quot;classpath:com/geek/ssh/entities/*.hbm.xml&quot;/&gt; &lt;/bean&gt; &lt;!--事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.geek.ssh.service.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt; &lt;/aop:config&gt; 在Resources目录下添加Struts2配置文件,并进行配置123&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;!--Action结点的class必须指向Spring中配置的bean--&gt;&lt;/package&gt; 在web.xml进行配置123456789101112131415161718&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 这时我们的SSH框架基本整合完毕啦。","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.yuanyang-miemie.win/tags/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"http://www.yuanyang-miemie.win/tags/Struts2/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.yuanyang-miemie.win/tags/Hibernate/"},{"name":"Maven","slug":"Maven","permalink":"http://www.yuanyang-miemie.win/tags/Maven/"}]},{"title":"Hanoi(汉诺塔)————Java小算法","date":"2017-03-15T06:43:00.000Z","path":"2017/03/15/汉诺塔(Hanoi)——小小算法/","text":"汉诺(Hanoi)塔源于古印度,是非常著名的智力趣题,大意如下： 勃拉玛是古印度的一个开天辟地的神，其在一个庙宇中留下了三根金刚石的棒，第一根上面套着64个大小不一的圆形金片。其中，最大的金片在最底下，其余的依次叠上去，且一个比一个小。勃拉玛要求众僧将该金刚石棒中的金片逐个地移动到另一根棒上，规定： 一次只能移动一个金片，且金片在放到棒上时，只能大的放在小的下面，但是可以利用中间的一根棒最为辅助。 问题分析 从上至下,我将盘一次标号为1、2、3…… 当只有一个盘的时候,只需要将其从A棒移动至C棒; 步骤: 1号:A ——&gt; C 当有两个盘时,需要先将第一个盘移动至B棒,再将第二个盘移动至C棒,再将第一个盘移动至C棒; 步骤: 1号:A ——&gt; B 2号:A ——&gt; C 1号:B ——&gt; C 当有3个盘子时,需要进行的步骤为: 1号:A ——&gt; C 2号:A ——&gt; B 1号:C ——&gt; B 3号:A ——&gt; C 1号:B ——&gt; A 2号:B ——&gt; C 1号:A ——&gt; C 可以看出，当号数与盘子总数相等时,进行的操作只有A ——&gt; C。所以可以将把A棒上的所有盘子借助B棒移动到C棒的整个过程总结为三步： 将A棒上的n-1个圆盘借助C棒移动到B棒上 将A棒上的一个圆盘移动到C棒上 将B棒上的圆盘借助A棒移动到C棒上 当然，当只有一个盘子时只需A ——&gt; C;两个盘子的时候，也不需要中介。 初态:移动n-1个圆盘:移动剩下的一个盘:移动B棒上的盘: 示例代码12345678910111213141516171819202122232425262728293031323334package com.yuanyang.example;import java.util.Scanner;public class Hanoi &#123; static long count; //移动的次数 /** * @param n 盘子总数 * @param a A棒 * @param b B棒 * @param c C棒 * @param disk 用来输出移动的第k个盘子 */ static void move(int n,char a,char b,char c,int disk)&#123;//A棒借助B棒移动到C棒 disk --; if (n==1) &#123;//当只有一个盘子的时候,直接从A棒移动至C棒 System.out.printf(&quot;第%d次移动:\\t第%d个盘子,圆盘从%c移动到%c棒\\n&quot;,++count,disk,a,c); &#125;else &#123;//当盘子大于一的时候。 move(n-1,a,c,b,disk);//将A棒上的n-1个盘子借助C棒移动到B棒 System.out.printf(&quot;第%d次移动:\\t第%d个盘子,圆盘从%c移动到%c棒\\n&quot;,++count,disk,a,c);//将最后一张盘子从A棒移到C棒 move(n-1,b,a,c,disk);//将B棒上剩下的n-1个盘子借助A棒移动到C棒 &#125; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入圆盘数:&quot;); int n = input.nextInt(); move(n,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,n + 1); System.out.printf(&quot;一共进行了%d次移动\\n&quot;,count); &#125;&#125; 这样，我们就可以得到结果了。但是，可以发现，移动的次数n和盘子数x存在 x = 2^n-1 的关系，所以，当盘子达到64个的时候，次数达到了18446744073709551615次，这就很尴尬了，这群僧人估计搬完是没戏了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.yuanyang-miemie.win/tags/随笔/"},{"name":"小小算法","slug":"小小算法","permalink":"http://www.yuanyang-miemie.win/tags/小小算法/"}]},{"title":"百钱百鸡————Java小算法","date":"2017-03-14T06:43:00.000Z","path":"2017/03/14/百钱百鸡小算法/","text":"百钱百鸡是一个非常经典的不定方程问题，最早源于我国古代的《算经》，这是古代著名数学家张丘建首次提出的。百钱百鸡问题原文如下： 鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买白鸡，问翁、母、雏各几何？ 大致的意思是，攻击5文钱一只，母鸡3文钱1只，小鸡3只1文钱，如果用100文钱买100只鸡，那么公鸡、母鸡和小鸡各应该买多少只呢？ 分析百钱买白鸡问题中，有三个变量：公鸡数量、母鸡数量、小鸡数量，分别设为x、y、z，这三者应该满足如下关系： x+y+z=100； 5x+3y+z/3=100； 三个变量，两个方程，因此这是一个不定方程组，这导致求解的结果不唯一。 示例代码编写一段代码，用于计算m钱n鸡的问题,当m=100且n=100时,正好是百钱百鸡问题。 123456789101112131415161718192021222324package com.example;public class Code &#123; public static void main(String[] args) &#123; System.out.println(&quot;百钱百鸡问题的解为:&quot;); buyChicken(100,100); &#125; public static void buyChicken(int m,int n)&#123; for (int x = 0;x &lt;= n;x++) //公鸡数量 for (int y = 0;y &lt;= n;y++) &#123; //母鸡数量 if (x + y &lt;= n) &#123; //公鸡和母鸡只和不能超过 n int z = n - x -y; //小鸡数量, 用到第一个方程 x + y + z = n if (z%3 == 0 &amp;&amp; x*5 + y*3 + z/3 == m) &#123; //小鸡数量必须为3的倍数, 且当第二个方程成立时, 得到正确结果 System.out.println(&quot;公鸡:&quot; + x + &quot; 母鸡:&quot; + y + &quot; 小鸡:&quot; + z); &#125;else continue; //当结果不满足条件时, 继续下一次循环 &#125;else break; //当公鸡和母鸡数超过 n 时, 退出当前循环 &#125; &#125;&#125; 这样，我们运行程序可以得到解： 百钱百鸡问题的解为: 公鸡:0 母鸡:25 小鸡:75 公鸡:4 母鸡:18 小鸡:78 公鸡:8 母鸡:11 小鸡:81 公鸡:12 母鸡:4 小鸡:84 这里我采用了穷举的方法，将所有的值进行穷举，寻找方程组的解。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.yuanyang-miemie.win/tags/随笔/"},{"name":"小小算法","slug":"小小算法","permalink":"http://www.yuanyang-miemie.win/tags/小小算法/"}]},{"title":"我的第一个小项目——GEEK网工作室主页","date":"2017-03-13T07:31:01.000Z","path":"2017/03/13/我的第一个小项目——GEEK网工作室主页/","text":"很快,就到了大二的寒假，大学的生活就这样过去了接近一半，之前听说大二寒假会有项目什么的,已经准好了心理准备。但第一次着手项目，还是有点小紧张在这之前我已经看了一些框架，也需要把框架应用起来。光是纸上谈兵是没有用的，在实际操作中，必有变数。 准备工作我们组是5个前端，一个后台。并我担任组长。看了之前学长学姐们做的主页，我们也慢慢开始琢磨我们自己网站的构造。 可是没有UI、没有产品，这对于我来说是一次历练，因为我之前没有经验，不知道整个项目流程是什么，但这也是这次项目的目的，让我们熟悉项目流程。 我们在放假后进行了两次讨论，确定我们用什么技术、做成什么样等等；我画出了所有页面的原型图，整理了网站运行流程然后分配任务。 丑丑的原型图： 制作网站当着手代码的时候，我发现网站的逻辑其实非常简单，因为是一个介绍性的网站，虽然有些内容需要连接数据库，但整个运行逻辑很清晰。 由于只有我一个后台，所以我必须早日完成，并把接口给他们，我用了4-5天完成整个代码的书写并完成自测。 我和长街（花名）一起完成后台了管理页面，而其他四个前端写的主页面。我估计他们用了一周左右吧，因为大家都是第一次，对交互需要摸索。 发现不足本来我为我们的项目搭建了一个github项目，方便代码共享，但只有我一个后台，我并没有太在意去用这个。而他们5个前端也没使用github，我觉得这是一个不足的地方，每次他们更新了代码都要发给我，在我这里测试，即使我为他们搭建了环境之后，当我的代码改动之后，他们的又需要更新。我作为组长，应该组织他们使用起来，不然交互的时候会非常麻烦，以后希望我们都能改进。 小小总结总的来说，我觉得还行吧。虽然我设计的后台的管理页面有点丑，毕竟我对这方面没有灵感。这次对我们6个人来说都是一次成长，虽然项目很小，并且只有我们知道，但是麻雀虽小五脏俱全。我们得到锻炼就行了，这就是目的。希望以后的项目我们要避免我们这次项目里面发现的问题，提高合作效率，做得更好！ 附上我们的网站截图，真的有点丑，怪我怪我。","tags":[{"name":"项目取经","slug":"项目取经","permalink":"http://www.yuanyang-miemie.win/tags/项目取经/"}]}]