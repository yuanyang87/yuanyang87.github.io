[{"title":"Spring MVC 搭建 - Hello world","date":"2017-04-27T07:31:01.000Z","path":"2017/04/27/Spring MVC 搭建/","text":"现在的Web框架基本都采用了MVC(model-view-Controller)设计模式,其中,Servlet和Filter都可以充当控制器.Spring MVC采用一个Servlet作为控制器,而Struts2则采用的Filter作为控制器. 对于他们的区别我在这里不多赘述,可以参见这篇文章SpringMVC与Struts2区别与比较总结 Spring MVC的搭建可以通过Java代码的方式(在《Spring 实战》一书中有详细讲解),也可以通过配置文件的方式,这里讲到的是运用配置文件的方式进行搭建. 这是一个毫无技术含量的最简单例子 使用工具: idea maven 当然啦~如果你不想使用Maven可以直接跳过前两步 Demo结构: 首先需要搭建一个Web项目 可以参见Idea 使用 Maven 搭建 Web 项目 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置classpath 12345678910111213141516&lt;build&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;!--配置Classpath--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 配置web.xml 123456789101112131415161718192021222324252627&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;&lt;web-app&gt; &lt;!--spring的配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring MVC必须的servlet,他会帮你把Spring的配置文件到application域中--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--Spring MVC的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置applicationContext.xml 1&lt;context:component-scan base-package=&quot;com.geek&quot;/&gt; 配置dispatcher-servlet.xml 12345678910&lt;!--启动Spring MVC的注解--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--自动扫描包--&gt;&lt;context:component-scan base-package=&quot;com.geek&quot;/&gt;&lt;!--视图解析器--&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; &lt;mvc:annotation-driven/&gt;这句话非常关键!如果不写会导致@Controller注解不能使用 TestController.java 1234567891011121314@Controllerpublic class TestController &#123; @Autowired private TestService service; @RequestMapping(&quot;/test&quot;) public String Test(String s, HttpServletRequest request)&#123; service.show(); request.setAttribute(&quot;s&quot;,s); return &quot;index&quot;;//由于前面配置了视图解析器,此处会跳转到index.jsp页面 &#125;&#125; 在这里使用了@Controller注解,逻辑上标志着这个类是一个控制器,让编程过程中更容易理解其中的@RequestMapping(&quot;/test&quot;)指将这个url(localhost:8080/test)映射到此方法上,在Spring MVC中以一个方法为上下文进行拦截. TestService.java 12345678@Servicepublic class TestService &#123; public void show()&#123; System.out.println(&quot;success&quot;); &#125;&#125; index.jsp 123456789&lt;%@page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html&quot;%&gt;&lt;html&gt;&lt;body&gt;&lt;% String s = (String) request.getAttribute(&quot;s&quot;); out.print(s!=null?s:&quot;hello&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器输入 http://localhost:8080/test?s=123456 可以看到控制台打印success,index.jsp页面的显示由hello变为123456 这样,Spring MVC 的一个小Demo就算完成了,当然,这里面使用了Spring的自动装配,整体上非常的简单例子,动手试试吧~","tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"高性能Mysql学习笔记之事务","date":"2017-04-26T15:48:59.000Z","path":"2017/04/26/高性能Mysql学习笔记之事务/","text":"什么是事务?事务就是一组原子性的SQL查询,或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就会执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。简单的说，一个事务内的语句，要么全部执行成功，要么全部执行失败。 事务的ACID特性ACID表示事务的原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)。一个运行良好的事务处理系统，必须具备这些标准特性。 原子性(atomicity) 一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能只执行其中的一部分操作。 一致性(consistency) 数据库总是从一个一致性的状态换到另一个一致性的状态。 隔离性(isolation) 通常来说：一个事务所做的修改在最终提交前,对其他事务是不可见的。 持久性(durability) 一旦事务提交,则其所做的修改就会永久保存到数据库中。此时即使系统崩溃,修改的数据也不会丢失。 隔离级别 READ UNCOMMITTED(读未提交) 也叫==脏读==,在这个级别中,事务中的修改,即使没有提交,对其他事务也是可见的.一般都不采用. READ COMMITTED(读已提交) 也叫==不可重复读==,因为两次相同的查询可能得到不同的结果.大多数数据库都默认使用这种隔离级别,一个事务从开始直到提交之前,所做的任何修改对其他事务都是不可见的. REPEATABLE READ(可重复读) ==Mysql默认隔离级别==解决了==脏读==的问题,该级别保证了在同一个事务中多次读取同样的记录结果是一样的.但无法解决==幻读==的问题。幻读(Phantom Read),指当某个事务在读取某个范围内的记录时,另外一个事务又在该范围插入了新的记录,当之前的事务再次读取该范围的记录时,会产生换行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制解决了幻读问题。 SERIALIZABLE(可串行化) 这是最高的个理解别,它会通过强制事务串行执行,避免了前面说的幻读问题.简单地说SERIALIZABLE会在读取的每一行数据上都加上锁,所以可能导致大量的超时和争锁时间的问题.实际应用中也很少使用,只有在急需要保持数据一致且接受没有并发的情况下,才考虑使用. 隔离级别 脏读可能性 不可重复读可能性 幻读可能性 加锁读 READ UNCOMMITTED YES YES YES NO READ COMMITTED NO YES YES NO REPEATABLE NO NO YES NO SERIALIZABLE NO NO NO YES 死锁死锁是指两个或多个事务在同一个资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象.当多个事务试图以不同的顺序锁定资源时,就可能会产生死锁,多个事务同时锁定同一个资源时,也会产生死锁 例如: 事务1: 1234start transaction;update stock_price set close = 45.50 where stock_id = 4 and date = &apos;2017-4-26&apos;;update stock_price set close = 19.80 where stock_id = 3 and date = &apos;2017-4-27&apos;;commit; 事务2: 1234start transaction;update stock_price set high = 20.10 where stock_id = 3 and date = &apos;2017-4-27&apos;;update stock_price set high = 47.20 where stock_id = 4 and date = &apos;2017-4-26&apos;;commit; 如果凑巧,两个事务均执行了第一条update语句,同时锁定了该资源,当尝试执行第二条update语句的时候,去发现资源已经被锁定,两个事务都等待对方释放锁,则陷入死循环,形成死锁 为了解决这种问题,数据库系统实现了各种死锁检测和死锁超时机制.比如InnoDB存储引擎目前的处理方法是将持有最少级排他锁的事务进行回滚.","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"Spring的声明式事务-Transactional","date":"2017-04-20T07:31:01.000Z","path":"2017/04/20/Transactional-Spring的声明式事务/","text":"一、Spring的声明式事务 需要在xml文件中配置 1234567891011121314151617181920212223&lt;!--配置事务管理器类--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--这里的dataSource引用前边配置好的dataSource--&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--事务的建议--&gt;&lt;tx:advice id=&quot;interceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置事务切面--&gt;&lt;aop:config proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;&gt; &lt;!--切点为该包下的所有类的所有方法,任意返回值,任意参数--&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* geek.service.*.* (..))&quot;/&gt; &lt;!--在切点处加入事务--&gt; &lt;aop:advisor advice-ref=&quot;interceptor&quot; pointcut-ref=&quot;txPointCut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; &lt;tx:advice.../&gt;节点详情如下图 name:指定方法的名称可以使用通配符 propagation:指定事务的传播行为,默认为为PROPAGATION_REQUIRED PROPAGATION_REQUIRED:要求在事务环境中执行该方法,如果当前执行线程已经处于事务环境中,则直接调用;如果当前线程不处于事务环境中,则启动新的事务后执行该方法. PROPAGATION_MANDATORY:要求调用该方法的线程必须处于事务中,否则抛出异常 PROPAGATION_NESTED:即使执行该方法的线程已经处于事务中们也依然启动新的事务,方法在嵌套的事务里执行;即使执行该方法的线程未处于事务环境中,也启动新的事务,然后执行该方法,此时与默认情况一致. PROPAGATION_NEVER:不允许调用该方法的线程处于事务环境中,如果调用该方法的线程处于事务环境中,则抛出异常 PROPAGATION_NOT_SUPPORTED:如果调用该方法的线程处于事务中,则先暂停当前事务,然后执行该方法 PROPAGATION_REQUIRED_NEW:该方法要求在新的事务环境中执行,如果当前执行线程已处于事务环境中,则先暂停当前事务,启动新的事务后执行该方法,如果当前线程不处于事务环境中,则启动新的事务后执行方法. PROPAGATION_SUPPORTS:如果当前线程处于事务环境中,则使用当前事务,否则不使用事务 isolation:指定事务的隔离级别 timeout:指定事务的超时时间 read-only:指定事务是否只读 rollback-for:指定触发事务回滚的异常类(全类名限定),可以指定多个,用英文逗号,隔开 no-rollback-for:指定不处罚事务回滚的异常类(全类名限定),可以指定多个,用英文逗号,隔开 二、使用@Transactional注解进行事务管理 需要在xml文件里配置 123456&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--启动@Transactional注解--&gt;&lt;tx:annotation-driven transaction-manager = &quot;transactionManager&quot;/&gt; @Transactional注解即可以用于修饰Spring Bean类,也可以用于修饰Bean类中的某个方法 如果使用该注解修饰Bean类,表明这些事务设置对整个Bean起作用;如果使用该注解修饰Bean类的方法,则表明这些事务设置只对该方法有效。 @Transactional注解的属性: isolation:用于指定事物的隔离级别.默认为底层事务的隔离级别 noRollbackFor:用于指定遇到某个特定异常时强制不回滚事务 noRollbackForClassName:指定遇到特定的多个异常时强制不回滚事务,可以指定多个异常类名 propagation:指定事务的传播行为 readOnly:指定是否只读 rollbackFor:指定遇到特定异常时强制回滚事务 rollbackForClassName:指定遇到特定的多个异常时强制回滚事务.可以设置多个异常类名 timeout:指定事务的超时时长 @Transactional注解中所指定的属性与&lt;tx:advice.../&gt;元素中所指定的事务属性基本上是对应的。","tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Idea-使用Mybatis-generator插件快速生成Mybatis相关代码","date":"2017-04-19T14:43:00.000Z","path":"2017/04/19/idea-使用Mybatis-generator插件快速生成Mybatis代码/","text":"使用这个插件可以快速生成一些代码,包含 实体类/Mapper接口/*Mapper.xml文件 首先,我们需要搭建一个Maven的项目。 在pom.xml中添加代码1234567891011121314151617181920212223242526272829&lt;plugins&gt; &lt;plugin&gt; &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;yourLocation/mybatis-generator-config.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; 注意,plugins标签是build标签的子标签 添加好之后,我们就需要配置mybatis-generator-config.xml配置文件中的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration&gt; &lt;!-- 本地数据库驱动程序jar包的全路径 --&gt; &lt;classPathEntry location=&quot;&quot;/&gt; &lt;context id=&quot;context&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库的相关配置 --&gt; &lt;jdbcConnection driverClass=&quot;&quot; connectionURL=&quot;&quot; userId=&quot;&quot; password=&quot;&quot;/&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 实体类生成的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;目标包&quot; targetProject=&quot;目标项目classpath&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- *Mapper.xml 文件的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;目标包&quot; targetProject=&quot;目标项目classpath&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper 接口文件的位置 --&gt; &lt;javaClientGenerator targetPackage=&quot;目标包&quot; targetProject=&quot;目标项目classpath&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 相关表的配置 --&gt; &lt;table tableName=&quot;表名&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 随后,在idea的右侧栏点击Maven,选中添加的Mybatis-generator插件并运行,就可以得到相应的代码啦~ 是不是很简单啊? 那就快动手试试吧!","tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Idea 使用 Maven 搭建 Web 项目","date":"2017-03-28T07:31:01.000Z","path":"2017/03/28/Idea 使用 Maven 搭建 Web 项目/","text":"Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 使用它来搭建项目可以省去很多操作，它不仅有依赖管理、自动生成项目站点等超酷的特性， 还可以让你从琐碎的手工劳动中解脱出来，帮你规范整个组织的构建系统。（可以通过《Maven 实战》一书进行详细学习） 搭建Web工程步骤： File-&gt;new-&gt;Project 选择 Maven 创建一个简单的 Web工程 输入 GroupId 与 ArtifactId 用来唯一标识你的项目 添加一个变量,目的是为了让 Idea 创建 Maven 项目更快 输入项目名称完成创建，并得到如下的目录 此时还并不算创建完毕，虽然添加服务器后可以运行，但还需要做一些简单的修饰 Ctrl+Alt+Shift+s 打开 Project Structure ，添加文件夹，并设置相应的功能模块 main目录下添加一个 java 文件夹，设置为 Sources src 目录下添加一个 test 文件夹,用于存放测试相关文件 test 目录下添加一个 java 文件夹，设置为 Tests test 目录下添加一个 resources 文件夹，设置为 Test Resources 添加 Tomcat服务器 点击上面的按钮，Edit Configurations... 点击 + 添加本地服务器 发布当前的项目 至此，Web 项目搭建完毕，就可以疯狂撸代码了，请开始你的表演~","tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://yoursite.com/tags/小技巧/"}]},{"title":"idea + SSH框架整合","date":"2017-03-28T06:43:00.000Z","path":"2017/03/28/idea+SSH框架整合/","text":"Spring4 Struts2 Hibernate5 整合 是现在比较流行的一种开发方式，许多网站都使用了这种架构进行开发。那么怎么整合这三大框架？ 两个问题: Spring 整合 Hibernate 整合什么？ 1) 由 IOC 容器管理 Hibernagte 的 SessionFactory 2) 让 Hibernate 使用上 Spring 的声明式事务 Spring 整合 Struts2 整合什么？ 1) 让 Spring 管理 Struts2 的 Action 首先用搭建一个Maven管理的Web项目，可以参考我的这篇博文:传送门 搭建完成之后，我们需要加入相关jar包并进行配置 第一步: 在pom.xml中添加jar包依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273&lt;dependencies&gt; &lt;!--Junit单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--添加hibernate的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.8.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.common&lt;/groupId&gt; &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt; &lt;version&gt;5.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.3.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.0.3.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.spec.javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jboss-transaction-api_1.2_spec&lt;/artifactId&gt; &lt;version&gt;1.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--依赖log4j slf4j--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Commons--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--配置Spring所需要的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--Struts2--&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-commons&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-tree&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.20.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ognl&lt;/groupId&gt; &lt;artifactId&gt;ognl&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.15.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts.xwork&lt;/groupId&gt; &lt;artifactId&gt;xwork-core&lt;/artifactId&gt; &lt;version&gt;2.3.15.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-Struts2整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!--aspectj--&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--配置jdbc所需要的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!--c3p0连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第二步: 在pom.xml中设置classpath 123456789101112131415&lt;build&gt; &lt;finalName&gt;ssh_demo&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 第三步: 添加Hibernate配置文件 ctrl+alt+shift+s 打开 Project Structure 选择 Facets 添加 Hibernate 选择 Hibernate 点击右侧添加配置文件 找到配置文件，并添加简单的配置，数据源的配置在 Spring 中进行 12345678&lt;!--方言--&gt;&lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL57InnoDBDialect&lt;/property&gt;&lt;!--显示SQL--&gt;&lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;&lt;!--格式化SQL--&gt;&lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;&lt;!--生成表的策略--&gt;&lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; 第四步: 添加Spring配置文件,并整合Hibernate 直接在Resources下添加Spring的配置文件 123456789101112131415161718192021222324252627282930313233343536&lt;!--配置数据源，请自定义取值--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt; &lt;/bean&gt;&lt;!--SessionFactory--&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappingLocations&quot; value=&quot;classpath:com/geek/ssh/entities/*.hbm.xml&quot;/&gt; &lt;/bean&gt; &lt;!--事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.geek.ssh.service.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt; &lt;/aop:config&gt; 第五步： 在Resources目录下添加Struts2配置文件,并进行配置 123&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;!--Action结点的class必须指向Spring中配置的bean--&gt;&lt;/package&gt; 第六步: 在web.xml进行配置 123456789101112131415161718&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 这时我们的SSH框架基本整合完毕啦。","tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/tags/Struts2/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"Hanoi(汉诺塔)————Java小算法","date":"2017-03-15T06:43:00.000Z","path":"2017/03/15/汉诺塔(Hanoi)——小小算法/","text":"汉诺(Hanoi)塔源于古印度,是非常著名的智力趣题,大意如下： 勃拉玛是古印度的一个开天辟地的神，其在一个庙宇中留下了三根金刚石的棒，第一 根上面套着64个大小不一的圆形金片。其中，最大的金片在最底下，其余的依次叠上 去，且一个比一个小。勃拉玛要求众僧将该金刚石棒中的金片逐个地移动到另一根棒 上，规定： 一次只能移动一个金片，且金片在放到棒上时，只能大的放在小的下面，但是可以利用中间的一根棒最为辅助。 问题分析 从上至下,我将盘一次标号为1、2、3…… 当只有一个盘的时候,只需要将其从A棒移动至C棒; 步骤: 1号:A ——&gt; C 当有两个盘时,需要先将第一个盘移动至B棒,再将第二个盘移动至C棒,再将第一个盘移动至C棒; 步骤: 1号:A ——&gt; B 2号:A ——&gt; C 1号:B ——&gt; C 当有3个盘子时,需要进行的步骤为: 1号:A ——&gt; C 2号:A ——&gt; B 1号:C ——&gt; B 3号:A ——&gt; C 1号:B ——&gt; A 2号:B ——&gt; C 1号:A ——&gt; C 可以看出，当号数与盘子总数相等时,进行的操作只有A ——&gt; C。所以可以将把A棒上的所有盘子借助B棒移动到C棒的整个过程总结为三步： 将A棒上的n-1个圆盘借助C棒移动到B棒上 将A棒上的一个圆盘移动到C棒上 将B棒上的圆盘借助A棒移动到C棒上 当然，当只有一个盘子时只需A ——&gt; C;两个盘子的时候，也不需要中介。 初态:移动n-1个圆盘:移动剩下的一个盘:移动B棒上的盘: 示例代码12345678910111213141516171819202122232425262728293031323334package com.yuanyang.example;import java.util.Scanner;public class Hanoi &#123; static long count; //移动的次数 /** * @param n 盘子总数 * @param a A棒 * @param b B棒 * @param c C棒 * @param disk 用来输出移动的第k个盘子 */ static void move(int n,char a,char b,char c,int disk)&#123;//A棒借助B棒移动到C棒 disk --; if (n==1) &#123;//当只有一个盘子的时候,直接从A棒移动至C棒 System.out.printf(&quot;第%d次移动:\\t第%d个盘子,圆盘从%c移动到%c棒\\n&quot;,++count,disk,a,c); &#125;else &#123;//当盘子大于一的时候。 move(n-1,a,c,b,disk);//将A棒上的n-1个盘子借助C棒移动到B棒 System.out.printf(&quot;第%d次移动:\\t第%d个盘子,圆盘从%c移动到%c棒\\n&quot;,++count,disk,a,c);//将最后一张盘子从A棒移到C棒 move(n-1,b,a,c,disk);//将B棒上剩下的n-1个盘子借助A棒移动到C棒 &#125; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入圆盘数:&quot;); int n = input.nextInt(); move(n,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,n + 1); System.out.printf(&quot;一共进行了%d次移动\\n&quot;,count); &#125;&#125; 这样，我们就可以得到结果了。但是，可以发现，移动的次数n和盘子数x存在 x = 2^n-1 的关系，所以，当盘子达到64个的时候，次数达到了18446744073709551615次，这就很尴尬了，这群僧人估计搬完是没戏了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"小小算法","slug":"小小算法","permalink":"http://yoursite.com/tags/小小算法/"}]},{"title":"百钱百鸡————Java小算法","date":"2017-03-14T06:43:00.000Z","path":"2017/03/14/百钱百鸡小算法/","text":"百钱百鸡是一个非常经典的不定方程问题，最早源于我国古代的《算经》，这是古代著名数学家张丘建首次提出的。百钱百鸡问题原文如下： 鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买白鸡，问翁、母、雏各几何？ 大致的意思是，攻击5文钱一只，母鸡3文钱1只，小鸡3只1文钱，如果用100文钱买100只鸡，那么公鸡、母鸡和小鸡各应该买多少只呢？ 分析百钱买白鸡问题中，有三个变量：公鸡数量、母鸡数量、小鸡数量，分别设为x、y、z，这三者应该满足如下关系： x+y+z=100； 5x+3y+z/3=100； 三个变量，两个方程，因此这是一个不定方程组，这导致求解的结果不唯一。 示例代码编写一段代码，用于计算m钱n鸡的问题,当m=100且n=100时,正好是百钱百鸡问题。 123456789101112131415161718192021222324package com.example;public class Code &#123; public static void main(String[] args) &#123; System.out.println(&quot;百钱百鸡问题的解为:&quot;); buyChicken(100,100); &#125; public static void buyChicken(int m,int n)&#123; for (int x = 0;x &lt;= n;x++) //公鸡数量 for (int y = 0;y &lt;= n;y++) &#123; //母鸡数量 if (x + y &lt;= n) &#123; //公鸡和母鸡只和不能超过 n int z = n - x -y; //小鸡数量, 用到第一个方程 x + y + z = n if (z%3 == 0 &amp;&amp; x*5 + y*3 + z/3 == m) &#123; //小鸡数量必须为3的倍数, 且当第二个方程成立时, 得到正确结果 System.out.println(&quot;公鸡:&quot; + x + &quot; 母鸡:&quot; + y + &quot; 小鸡:&quot; + z); &#125;else continue; //当结果不满足条件时, 继续下一次循环 &#125;else break; //当公鸡和母鸡数超过 n 时, 退出当前循环 &#125; &#125;&#125; 这样，我们运行程序可以得到解： 百钱百鸡问题的解为: 公鸡:0 母鸡:25 小鸡:75 公鸡:4 母鸡:18 小鸡:78 公鸡:8 母鸡:11 小鸡:81 公鸡:12 母鸡:4 小鸡:84 这里我采用了穷举的方法，将所有的值进行穷举，寻找方程组的解。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"小小算法","slug":"小小算法","permalink":"http://yoursite.com/tags/小小算法/"}]},{"title":"我的第一个小项目——GEEK网工作室主页","date":"2017-03-13T07:31:01.000Z","path":"2017/03/13/我的第一个小项目——GEEK网工作室主页/","text":"很快,就到了大二的寒假，大学的生活就这样过去了接近一半，之前听说大二寒假会有项目什么的,已经准好了心理准备。 但第一次着手项目，还是有点小紧张 在这之前我已经看了一些框架，也需要把框架应用起来。光是纸上谈兵是没有用的，在实际操作中，必有变数。 准备工作我们组是5个前端，一个后台。并我担任组长。看了之前学长学姐们做的主页，我们也慢慢开始琢磨我们自己网站的构造。 可是没有UI、没有产品，这对于我来说是一次历练，因为我之前没有经验，不知道整个项目流程是什么，但这也是这次项目的目的，让我们熟悉项目流程。 我们在放假后进行了两次讨论，确定我们用什么技术、做成什么样等等；我画出了所有页面的原型图，整理了网站运行流程然后分配任务。 丑丑的原型图： 制作网站当着手代码的时候，我发现网站的逻辑其实非常简单，因为是一个介绍性的网站，虽然有些内容需要连接数据库，但整个运行逻辑很清晰。 由于只有我一个后台，所以我必须早日完成，并把接口给他们，我用了4-5天完成整个代码的书写并完成自测。 我和长街（花名）一起完成后台了管理页面，而其他四个前端写的主页面。我估计他们用了一周左右吧，因为大家都是第一次，对交互需要摸索。 发现不足本来我为我们的项目搭建了一个github项目，方便代码共享，但只有我一个后台，我并没有太在意去用这个。而他们5个前端也没使用github，我觉得这是一个不足的地方，每次他们更新了代码都要发给我，在我这里测试，即使我为他们搭建了环境之后，当我的代码改动之后，他们的又需要更新。我作为组长，应该组织他们使用起来，不然交互的时候会非常麻烦，以后希望我们都能改进。 小小总结总的来说，我觉得还行吧。虽然我设计的后台的管理页面有点丑，毕竟我对这方面没有灵感。这次对我们6个人来说都是一次成长，虽然项目很小，并且只有我们知道，但是麻雀虽小五脏俱全。我们得到锻炼就行了，这就是目的。希望以后的项目我们要避免我们这次项目里面发现的问题，提高合作效率，做得更好！ 附上我们的网站截图，真的有点丑，怪我怪我。","tags":[{"name":"项目取经","slug":"项目取经","permalink":"http://yoursite.com/tags/项目取经/"}]}]